//! RISC-V Architecture Test suite runner.
//!
//! Runs the official riscv-arch-test suite and compares output signatures
//! against reference values generated by Spike.

use std::fs;
use std::path::{Path, PathBuf};
use std::process::Command;
use std::time::Duration;

use rvr_emit::Backend;

use super::riscv_tests::{TestResult, TestSummary, print_result};
use crate::{CompileOptions, Compiler, Runner, compile_with_options};

/// Signature region start address (must match model_test.h and link.ld).
/// Not directly used in code - signature bounds are read from ELF symbols.
#[allow(dead_code)]
pub const SIG_START_ADDR: u64 = 0x80002000;

/// Maximum signature region size (64KB should be enough for any test).
const MAX_SIG_SIZE: usize = 0x10000;

/// Tests to skip (not compatible with static recompilation).
const SKIP_TESTS: &[&str] = &[
    // fence.i tests self-modifying code
    "fence_i", // We don't support fence instructions that affect external memory
    "fence-01",
];

/// Path to the harness files (model_test.h, link.ld) relative to this module.
const HARNESS_DIR: &str = concat!(env!("CARGO_MANIFEST_DIR"), "/src/commands/test/arch_tests");

// ============================================================================
// Test Categories
// ============================================================================

/// RISC-V architecture test category.
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
pub enum ArchTestCategory {
    // RV64 categories
    Rv64iI,      // rv64i_m/I - Base integer
    Rv64iM,      // rv64i_m/M - Multiply/divide
    Rv64iA,      // rv64i_m/A - Atomics
    Rv64iC,      // rv64i_m/C - Compressed
    Rv64iB,      // rv64i_m/B - Bit manipulation (Zba, Zbb, Zbc, Zbs)
    Rv64iZicond, // rv64i_m/Zicond - Conditional ops
    // RV32 categories
    Rv32iI,
    Rv32iM,
    Rv32iA,
    Rv32iC,
    Rv32iB,
    Rv32iZicond,
}

impl ArchTestCategory {
    /// All supported test categories.
    pub const ALL: &'static [ArchTestCategory] = &[
        Self::Rv64iI,
        Self::Rv64iM,
        Self::Rv64iA,
        Self::Rv64iC,
        Self::Rv64iB,
        Self::Rv64iZicond,
        Self::Rv32iI,
        Self::Rv32iM,
        Self::Rv32iA,
        Self::Rv32iC,
        Self::Rv32iB,
        Self::Rv32iZicond,
    ];

    /// RV64 categories only.
    pub const RV64: &'static [ArchTestCategory] = &[
        Self::Rv64iI,
        Self::Rv64iM,
        Self::Rv64iA,
        Self::Rv64iC,
        Self::Rv64iB,
        Self::Rv64iZicond,
    ];

    /// RV32 categories only.
    pub const RV32: &'static [ArchTestCategory] = &[
        Self::Rv32iI,
        Self::Rv32iM,
        Self::Rv32iA,
        Self::Rv32iC,
        Self::Rv32iB,
        Self::Rv32iZicond,
    ];

    /// Parse from string (e.g., "rv64i-I" or "rv64i_m/I").
    pub fn parse(s: &str) -> Option<Self> {
        // Normalize: replace / and _ with -
        let normalized = s.to_lowercase().replace(['/', '_'], "-");
        match normalized.as_str() {
            "rv64i-m-i" | "rv64i-i" => Some(Self::Rv64iI),
            "rv64i-m-m" | "rv64i-m" => Some(Self::Rv64iM),
            "rv64i-m-a" | "rv64i-a" => Some(Self::Rv64iA),
            "rv64i-m-c" | "rv64i-c" => Some(Self::Rv64iC),
            "rv64i-m-b" | "rv64i-b" => Some(Self::Rv64iB),
            "rv64i-m-zicond" | "rv64i-zicond" => Some(Self::Rv64iZicond),
            "rv32i-m-i" | "rv32i-i" => Some(Self::Rv32iI),
            "rv32i-m-m" | "rv32i-m" => Some(Self::Rv32iM),
            "rv32i-m-a" | "rv32i-a" => Some(Self::Rv32iA),
            "rv32i-m-c" | "rv32i-c" => Some(Self::Rv32iC),
            "rv32i-m-b" | "rv32i-b" => Some(Self::Rv32iB),
            "rv32i-m-zicond" | "rv32i-zicond" => Some(Self::Rv32iZicond),
            _ => None,
        }
    }

    /// Parse comma-separated list of categories (or "all", "rv64", "rv32").
    pub fn parse_list(s: &str) -> Result<Vec<Self>, String> {
        let s_lower = s.to_lowercase();
        if s_lower == "all" {
            return Ok(Self::ALL.to_vec());
        }
        if s_lower == "rv64" {
            return Ok(Self::RV64.to_vec());
        }
        if s_lower == "rv32" {
            return Ok(Self::RV32.to_vec());
        }

        s.split(',')
            .map(|part| {
                Self::parse(part.trim()).ok_or_else(|| {
                    format!(
                        "unknown category '{}', expected one of: {}",
                        part,
                        Self::ALL
                            .iter()
                            .map(|c| c.as_str())
                            .collect::<Vec<_>>()
                            .join(", ")
                    )
                })
            })
            .collect()
    }

    /// Get string representation (for display).
    pub fn as_str(&self) -> &'static str {
        match self {
            Self::Rv64iI => "rv64i-I",
            Self::Rv64iM => "rv64i-M",
            Self::Rv64iA => "rv64i-A",
            Self::Rv64iC => "rv64i-C",
            Self::Rv64iB => "rv64i-B",
            Self::Rv64iZicond => "rv64i-Zicond",
            Self::Rv32iI => "rv32i-I",
            Self::Rv32iM => "rv32i-M",
            Self::Rv32iA => "rv32i-A",
            Self::Rv32iC => "rv32i-C",
            Self::Rv32iB => "rv32i-B",
            Self::Rv32iZicond => "rv32i-Zicond",
        }
    }

    /// Get the riscv-arch-test source subdirectory path (e.g., "rv64i_m/I").
    pub fn src_subdir(&self) -> &'static str {
        match self {
            Self::Rv64iI => "rv64i_m/I",
            Self::Rv64iM => "rv64i_m/M",
            Self::Rv64iA => "rv64i_m/A",
            Self::Rv64iC => "rv64i_m/C",
            Self::Rv64iB => "rv64i_m/B",
            Self::Rv64iZicond => "rv64i_m/Zicond",
            Self::Rv32iI => "rv32i_m/I",
            Self::Rv32iM => "rv32i_m/M",
            Self::Rv32iA => "rv32i_m/A",
            Self::Rv32iC => "rv32i_m/C",
            Self::Rv32iB => "rv32i_m/B",
            Self::Rv32iZicond => "rv32i_m/Zicond",
        }
    }

    /// Get output subdirectory (flat, e.g., "rv64i_m-I").
    pub fn out_subdir(&self) -> &'static str {
        match self {
            Self::Rv64iI => "rv64i_m-I",
            Self::Rv64iM => "rv64i_m-M",
            Self::Rv64iA => "rv64i_m-A",
            Self::Rv64iC => "rv64i_m-C",
            Self::Rv64iB => "rv64i_m-B",
            Self::Rv64iZicond => "rv64i_m-Zicond",
            Self::Rv32iI => "rv32i_m-I",
            Self::Rv32iM => "rv32i_m-M",
            Self::Rv32iA => "rv32i_m-A",
            Self::Rv32iC => "rv32i_m-C",
            Self::Rv32iB => "rv32i_m-B",
            Self::Rv32iZicond => "rv32i_m-Zicond",
        }
    }

    /// Get -march and -mabi flags for this category.
    pub fn march_mabi(&self) -> (&'static str, &'static str) {
        match self {
            // RV64 categories
            Self::Rv64iI => ("rv64im", "lp64"),
            Self::Rv64iM => ("rv64im", "lp64"),
            Self::Rv64iA => ("rv64ima", "lp64"),
            Self::Rv64iC => ("rv64imc", "lp64"),
            Self::Rv64iB => ("rv64im_zba_zbb_zbc_zbs", "lp64"),
            Self::Rv64iZicond => ("rv64im_zicond", "lp64"),
            // RV32 categories
            Self::Rv32iI => ("rv32im", "ilp32"),
            Self::Rv32iM => ("rv32im", "ilp32"),
            Self::Rv32iA => ("rv32ima", "ilp32"),
            Self::Rv32iC => ("rv32imc", "ilp32"),
            Self::Rv32iB => ("rv32im_zba_zbb_zbc_zbs", "ilp32"),
            Self::Rv32iZicond => ("rv32im_zicond", "ilp32"),
        }
    }
}

impl std::fmt::Display for ArchTestCategory {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.write_str(self.as_str())
    }
}

// ============================================================================
// Test Configuration
// ============================================================================

/// Configuration for running arch tests.
#[derive(Debug, Clone)]
pub struct ArchTestConfig {
    /// Test directory (default: bin/riscv-arch-test).
    pub test_dir: PathBuf,
    /// Reference signatures directory.
    pub refs_dir: PathBuf,
    /// Filter pattern.
    pub filter: Option<String>,
    /// Verbose output.
    pub verbose: bool,
    /// Timeout for each test in seconds.
    pub timeout_secs: u64,
    /// C compiler to use.
    pub compiler: Compiler,
    /// Code generation backend.
    pub backend: Backend,
}

impl Default for ArchTestConfig {
    fn default() -> Self {
        Self {
            test_dir: PathBuf::from("bin/riscv-arch-test"),
            refs_dir: PathBuf::from("bin/riscv-arch-test/references"),
            filter: None,
            verbose: false,
            timeout_secs: 30,
            compiler: Compiler::default(),
            backend: Backend::C,
        }
    }
}

impl ArchTestConfig {
    pub fn with_test_dir(mut self, dir: impl Into<PathBuf>) -> Self {
        self.test_dir = dir.into();
        self
    }

    pub fn with_refs_dir(mut self, dir: impl Into<PathBuf>) -> Self {
        self.refs_dir = dir.into();
        self
    }

    pub fn with_filter(mut self, filter: impl Into<String>) -> Self {
        self.filter = Some(filter.into());
        self
    }

    pub fn with_verbose(mut self, verbose: bool) -> Self {
        self.verbose = verbose;
        self
    }

    pub fn with_timeout(mut self, secs: u64) -> Self {
        self.timeout_secs = secs;
        self
    }

    pub fn with_compiler(mut self, compiler: Compiler) -> Self {
        self.compiler = compiler;
        self
    }

    pub fn with_backend(mut self, backend: Backend) -> Self {
        self.backend = backend;
        self
    }
}

// ============================================================================
// Build Configuration
// ============================================================================

/// Configuration for building arch tests.
#[derive(Debug, Clone)]
pub struct ArchBuildConfig {
    /// Test source directory (riscv-arch-test/riscv-test-suite).
    pub src_dir: PathBuf,
    /// Output directory for built binaries.
    pub out_dir: PathBuf,
    /// Reference signatures output directory.
    pub refs_dir: PathBuf,
    /// Toolchain prefix (e.g., "riscv64-unknown-elf-").
    pub toolchain: String,
    /// Categories to build.
    pub categories: Vec<ArchTestCategory>,
    /// Whether to generate reference signatures.
    pub gen_refs: bool,
}

impl ArchBuildConfig {
    pub fn new(categories: Vec<ArchTestCategory>) -> Self {
        Self {
            src_dir: PathBuf::from("programs/riscv-arch-test/riscv-test-suite"),
            out_dir: PathBuf::from("bin/riscv-arch-test"),
            refs_dir: PathBuf::from("bin/riscv-arch-test/references"),
            toolchain: String::new(),
            categories,
            gen_refs: true,
        }
    }

    pub fn with_src_dir(mut self, dir: impl Into<PathBuf>) -> Self {
        self.src_dir = dir.into();
        self
    }

    pub fn with_out_dir(mut self, dir: impl Into<PathBuf>) -> Self {
        self.out_dir = dir.into();
        self
    }

    pub fn with_refs_dir(mut self, dir: impl Into<PathBuf>) -> Self {
        self.refs_dir = dir.into();
        self
    }

    pub fn with_toolchain(mut self, toolchain: impl Into<String>) -> Self {
        self.toolchain = toolchain.into();
        self
    }

    pub fn with_gen_refs(mut self, gen_refs: bool) -> Self {
        self.gen_refs = gen_refs;
        self
    }
}

/// Result of building a category.
#[derive(Debug)]
pub struct ArchBuildResult {
    pub category: ArchTestCategory,
    pub built: usize,
    pub failed: usize,
    pub refs_generated: usize,
}

// ============================================================================
// Test Discovery
// ============================================================================

/// Check if a test should be skipped.
pub fn should_skip(name: &str) -> bool {
    for skip in SKIP_TESTS {
        if name.contains(skip) {
            return true;
        }
    }
    false
}

/// Discover arch test ELF files in the given directory.
pub fn discover_tests(test_dir: &Path, filter: Option<&str>) -> Vec<PathBuf> {
    let mut tests = Vec::new();

    if !test_dir.exists() {
        return tests;
    }

    discover_tests_recursive(test_dir, filter, &mut tests);
    tests.sort();
    tests
}

fn discover_tests_recursive(dir: &Path, filter: Option<&str>, tests: &mut Vec<PathBuf>) {
    let entries = match fs::read_dir(dir) {
        Ok(e) => e,
        Err(_) => return,
    };

    for entry in entries.flatten() {
        let path = entry.path();

        if path.is_dir() {
            discover_tests_recursive(&path, filter, tests);
            continue;
        }

        if !path.is_file() {
            continue;
        }

        let name = match path.file_name().and_then(|n| n.to_str()) {
            Some(n) => n,
            None => continue,
        };

        // Arch tests end with -01 (e.g., add-01, amoadd.w-01)
        if !name.ends_with("-01") {
            continue;
        }

        // Skip signature files
        if name.ends_with(".sig") {
            continue;
        }

        // Apply filter if specified
        if let Some(filter) = filter {
            // Check if filter matches path or name
            let path_str = path.to_string_lossy();
            if !path_str.contains(filter) && !name.contains(filter) {
                continue;
            }
        }

        tests.push(path);
    }
}

// ============================================================================
// Test Execution
// ============================================================================

/// Run a single arch test and compare signature.
pub fn run_test(
    elf_path: &Path,
    ref_path: &Path,
    timeout: Duration,
    compiler: &Compiler,
    backend: Backend,
) -> TestResult {
    let name = elf_path
        .file_name()
        .and_then(|n| n.to_str())
        .unwrap_or("unknown")
        .to_string();

    // Check skip list
    if should_skip(&name) {
        return TestResult::skip(name);
    }

    // Check reference file exists
    if !ref_path.exists() {
        return TestResult::fail(name, "missing reference signature");
    }

    // Create temp directory for compilation output
    let temp_dir = match tempfile::tempdir() {
        Ok(d) => d,
        Err(e) => return TestResult::fail(name, format!("temp dir failed: {}", e)),
    };

    let out_dir = temp_dir.path().join("out");

    // Compile with HTIF enabled
    let options = CompileOptions::new()
        .with_htif(true)
        .with_quiet(true)
        .with_compiler(compiler.clone())
        .with_backend(backend);

    if let Err(e) = compile_with_options(elf_path, &out_dir, options) {
        return TestResult::fail(name, format!("compile failed: {}", e));
    }

    // Run with timeout and extract signature
    let result = run_and_extract_signature(&out_dir, elf_path, timeout);

    match result {
        Ok(signature) => {
            // Load reference signature
            let reference = match fs::read_to_string(ref_path) {
                Ok(r) => r,
                Err(e) => {
                    return TestResult::fail(name, format!("failed to read reference: {}", e));
                }
            };

            // Compare signatures
            if compare_signatures(&signature, &reference) {
                TestResult::pass(name)
            } else {
                TestResult::fail(name, "signature mismatch")
            }
        }
        Err(e) => TestResult::fail(name, e),
    }
}

/// Run a compiled test with timeout and extract signature from memory.
fn run_and_extract_signature(
    lib_dir: &Path,
    elf_path: &Path,
    timeout: Duration,
) -> Result<String, String> {
    let (tx, rx) = std::sync::mpsc::channel();
    let lib_dir_clone = lib_dir.to_path_buf();
    let elf_path_clone = elf_path.to_path_buf();

    std::thread::spawn(move || {
        let mut runner = match Runner::load(&lib_dir_clone, &elf_path_clone) {
            Ok(r) => r,
            Err(e) => {
                let _ = tx.send(Err(format!("load failed: {}", e)));
                return;
            }
        };

        match runner.run() {
            Ok(_result) => {
                // Extract signature from memory using ELF symbols
                let sig = extract_signature_from_runner(&runner);
                let _ = tx.send(sig);
            }
            Err(e) => {
                let _ = tx.send(Err(format!("run failed: {}", e)));
            }
        }
    });

    match rx.recv_timeout(timeout) {
        Ok(result) => result,
        Err(std::sync::mpsc::RecvTimeoutError::Timeout) => Err("timeout".to_string()),
        Err(std::sync::mpsc::RecvTimeoutError::Disconnected) => Err("crash".to_string()),
    }
}

/// Read a u32 from runner memory at the given address.
fn read_u32(runner: &Runner, addr: u64) -> u32 {
    let mut buf = [0u8; 4];
    runner.read_memory(addr, &mut buf);
    u32::from_le_bytes(buf)
}

/// Extract signature from runner's memory using begin_signature/end_signature symbols.
fn extract_signature_from_runner(runner: &Runner) -> Result<String, String> {
    // Look up signature bounds from ELF symbols
    let sig_start = runner
        .lookup_symbol("begin_signature")
        .ok_or("begin_signature symbol not found")?;
    let sig_end = runner
        .lookup_symbol("end_signature")
        .ok_or("end_signature symbol not found")?;

    if sig_end <= sig_start {
        return Err("invalid signature bounds".to_string());
    }

    let sig_size = (sig_end - sig_start) as usize;
    if sig_size > MAX_SIG_SIZE {
        return Err(format!("signature too large: {} bytes", sig_size));
    }

    // Read all signature words
    let num_words = sig_size / 4;
    let mut signature_words = Vec::with_capacity(num_words);

    for i in 0..num_words {
        let addr = sig_start + (i as u64 * 4);
        let word = read_u32(runner, addr);
        signature_words.push(word);
    }

    // Format as hex lines (one 32-bit word per line, lowercase hex)
    let mut lines = Vec::new();
    for word in signature_words {
        lines.push(format!("{:08x}", word));
    }

    Ok(lines.join("\n"))
}

/// Compare two signatures (ignoring trailing whitespace and empty lines).
fn compare_signatures(actual: &str, reference: &str) -> bool {
    let actual_lines: Vec<&str> = actual
        .lines()
        .map(|l| l.trim())
        .filter(|l| !l.is_empty())
        .collect();
    let reference_lines: Vec<&str> = reference
        .lines()
        .map(|l| l.trim())
        .filter(|l| !l.is_empty())
        .collect();

    actual_lines == reference_lines
}

/// Run all arch tests with the given configuration.
pub fn run_all(config: &ArchTestConfig) -> TestSummary {
    let tests = discover_tests(&config.test_dir, config.filter.as_deref());
    let total = tests.len();
    let timeout = Duration::from_secs(config.timeout_secs);

    let mut summary = TestSummary::default();

    for (i, test_path) in tests.iter().enumerate() {
        // Derive reference path from test path
        let ref_path = derive_ref_path(&config.refs_dir, test_path);

        let result = run_test(
            test_path,
            &ref_path,
            timeout,
            &config.compiler,
            config.backend,
        );
        print_result(&result, i + 1, total, config.verbose);
        summary.add(result);
    }

    summary.record_metrics();
    summary
}

/// Derive reference signature path from test ELF path.
fn derive_ref_path(refs_dir: &Path, test_path: &Path) -> PathBuf {
    // Test path: bin/riscv-arch-test/rv64i_m-I/add-01
    // Ref path: bin/riscv-arch-test/references/rv64i_m-I/add-01.sig
    let test_name = test_path.file_name().unwrap_or_default();
    let category_dir = test_path
        .parent()
        .and_then(|p| p.file_name())
        .unwrap_or_default();

    refs_dir
        .join(category_dir)
        .join(format!("{}.sig", test_name.to_string_lossy()))
}

// ============================================================================
// Test Building
// ============================================================================

/// Find RISC-V GCC toolchain prefix.
pub fn find_toolchain() -> Option<String> {
    crate::build_utils::find_toolchain()
}

/// Check if Spike simulator is available.
pub fn find_spike() -> Option<String> {
    for name in ["spike", "riscv64-unknown-elf-spike"] {
        if Command::new("which")
            .arg(name)
            .output()
            .map(|o| o.status.success())
            .unwrap_or(false)
        {
            return Some(name.to_string());
        }
    }
    None
}

/// Get the path to the harness directory containing model_test.h and link.ld.
pub fn harness_dir() -> PathBuf {
    PathBuf::from(HARNESS_DIR)
}

/// Build tests for a single category.
pub fn build_category(
    category: ArchTestCategory,
    config: &ArchBuildConfig,
) -> Result<ArchBuildResult, String> {
    let src_subdir = category.src_subdir();
    let out_subdir = category.out_subdir();

    let test_src_dir = config.src_dir.join(src_subdir).join("src");
    let out_dir = config.out_dir.join(out_subdir);
    let refs_out_dir = config.refs_dir.join(out_subdir);

    if !test_src_dir.exists() {
        return Err(format!(
            "source directory not found: {}",
            test_src_dir.display()
        ));
    }

    fs::create_dir_all(&out_dir).map_err(|e| format!("failed to create output dir: {}", e))?;
    if config.gen_refs {
        fs::create_dir_all(&refs_out_dir)
            .map_err(|e| format!("failed to create refs dir: {}", e))?;
    }

    let (march, mabi) = category.march_mabi();
    let gcc = format!("{}gcc", config.toolchain);

    // Harness files are embedded in this crate
    let env_dir = harness_dir();
    let arch_test_env = config.src_dir.join("env");
    let link_ld = env_dir.join("link.ld");

    let mut built = 0;
    let mut failed = 0;
    let mut refs_generated = 0;

    // Find all .S files
    let entries = fs::read_dir(&test_src_dir).map_err(|e| format!("failed to read dir: {}", e))?;

    for entry in entries.flatten() {
        let path = entry.path();
        if path.extension().and_then(|s| s.to_str()) != Some("S") {
            continue;
        }

        let stem = match path.file_stem().and_then(|s| s.to_str()) {
            Some(s) => s,
            None => continue,
        };

        // Output: add-01 (no prefix, just the test name)
        let out_path = out_dir.join(stem);

        // Build the test
        let status = Command::new(&gcc)
            .arg(format!("-march={}", march))
            .arg(format!("-mabi={}", mabi))
            .args(["-static", "-mcmodel=medany", "-fvisibility=hidden"])
            .args(["-nostdlib", "-nostartfiles"])
            .arg(format!("-I{}", env_dir.display()))
            .arg(format!("-I{}", arch_test_env.display()))
            .arg(format!("-T{}", link_ld.display()))
            // Define RVMODEL header location
            .arg("-DRVMODEL_BOOT=")
            .arg(&path)
            .arg("-o")
            .arg(&out_path)
            .stderr(std::process::Stdio::piped())
            .status();

        match status {
            Ok(s) if s.success() => {
                built += 1;

                // Generate reference signature if requested
                if config.gen_refs {
                    let ref_path = refs_out_dir.join(format!("{}.sig", stem));
                    if generate_reference(&out_path, &ref_path, category).is_ok() {
                        refs_generated += 1;
                    }
                }
            }
            _ => failed += 1,
        }
    }

    Ok(ArchBuildResult {
        category,
        built,
        failed,
        refs_generated,
    })
}

/// Generate reference signature using Spike.
///
/// Runs the test on Spike (the RISC-V reference simulator) and uses its
/// `+signature=<file>` option to dump the signature region to a file.
fn generate_reference(
    elf_path: &Path,
    ref_path: &Path,
    category: ArchTestCategory,
) -> Result<(), String> {
    let spike = find_spike().ok_or("Spike not found")?;

    // Get ISA string for this category
    let isa = category_to_spike_isa(category);

    // Create temp file for signature output
    let temp_dir = tempfile::tempdir().map_err(|e| format!("failed to create temp dir: {}", e))?;
    let sig_file = temp_dir.path().join("signature.txt");

    // Run Spike with signature dumping
    let output = Command::new(&spike)
        .arg(format!("--isa={}", isa))
        .arg(format!("+signature={}", sig_file.display()))
        .arg("+signature-granularity=4")
        .arg(elf_path)
        .output()
        .map_err(|e| format!("failed to run Spike: {}", e))?;

    if !output.status.success() {
        return Err(format!(
            "Spike failed: {}",
            String::from_utf8_lossy(&output.stderr)
        ));
    }

    // Read and copy signature file
    let signature =
        fs::read_to_string(&sig_file).map_err(|e| format!("failed to read signature: {}", e))?;

    fs::write(ref_path, signature.trim()).map_err(|e| format!("failed to write ref: {}", e))?;

    Ok(())
}

/// Get Spike ISA string for a test category.
fn category_to_spike_isa(category: ArchTestCategory) -> &'static str {
    match category {
        ArchTestCategory::Rv64iI => "rv64im",
        ArchTestCategory::Rv64iM => "rv64im",
        ArchTestCategory::Rv64iA => "rv64ima",
        ArchTestCategory::Rv64iC => "rv64imc",
        ArchTestCategory::Rv64iB => "rv64im_zba_zbb_zbc_zbs",
        ArchTestCategory::Rv64iZicond => "rv64im_zicond",
        ArchTestCategory::Rv32iI => "rv32im",
        ArchTestCategory::Rv32iM => "rv32im",
        ArchTestCategory::Rv32iA => "rv32ima",
        ArchTestCategory::Rv32iC => "rv32imc",
        ArchTestCategory::Rv32iB => "rv32im_zba_zbb_zbc_zbs",
        ArchTestCategory::Rv32iZicond => "rv32im_zicond",
    }
}

/// Build all specified test categories.
pub fn build_tests(config: &ArchBuildConfig) -> Result<Vec<ArchBuildResult>, String> {
    if !config.src_dir.exists() {
        return Err(format!(
            "source directory not found: {}\nMake sure riscv-arch-test submodule is initialized",
            config.src_dir.display()
        ));
    }

    let mut results = Vec::new();

    for &category in &config.categories {
        match build_category(category, config) {
            Ok(result) => results.push(result),
            Err(e) => {
                eprintln!("  {}: {}", category, e);
            }
        }
    }

    Ok(results)
}

/// Print build results summary.
pub fn print_build_summary(results: &[ArchBuildResult]) {
    let total_built: usize = results.iter().map(|r| r.built).sum();
    let total_failed: usize = results.iter().map(|r| r.failed).sum();
    let total_refs: usize = results.iter().map(|r| r.refs_generated).sum();

    println!();
    println!(
        "Build complete: {} tests built, {} failed, {} references generated",
        total_built, total_failed, total_refs
    );
}

// ============================================================================
// Reference Generation
// ============================================================================

/// Configuration for generating references.
#[derive(Debug, Clone)]
pub struct GenRefsConfig {
    /// Test ELF directory.
    pub test_dir: PathBuf,
    /// Output directory for reference signatures.
    pub refs_dir: PathBuf,
    /// Categories to generate refs for.
    pub categories: Vec<ArchTestCategory>,
    /// Force regeneration even if refs exist.
    pub force: bool,
}

impl GenRefsConfig {
    pub fn new(categories: Vec<ArchTestCategory>) -> Self {
        Self {
            test_dir: PathBuf::from("bin/riscv-arch-test"),
            refs_dir: PathBuf::from("bin/riscv-arch-test/references"),
            categories,
            force: false,
        }
    }

    pub fn with_test_dir(mut self, dir: impl Into<PathBuf>) -> Self {
        self.test_dir = dir.into();
        self
    }

    pub fn with_refs_dir(mut self, dir: impl Into<PathBuf>) -> Self {
        self.refs_dir = dir.into();
        self
    }

    pub fn with_force(mut self, force: bool) -> Self {
        self.force = force;
        self
    }
}

/// Generate reference signatures for all tests in specified categories.
///
/// Uses Spike (the RISC-V reference simulator) to run each test and dump
/// its signature. These references serve as ground truth for verifying
/// rvr's correctness.
pub fn generate_references(config: &GenRefsConfig) -> Result<usize, String> {
    // Verify Spike is available
    let spike = find_spike().ok_or(
        "Spike not found. Install from https://github.com/riscv-software-src/riscv-isa-sim",
    )?;
    eprintln!("Using Spike: {}", spike);

    let mut generated = 0;

    for &category in &config.categories {
        let out_subdir = category.out_subdir();
        let test_dir = config.test_dir.join(out_subdir);
        let refs_dir = config.refs_dir.join(out_subdir);

        if !test_dir.exists() {
            eprintln!("  {}: test directory not found, skipping", category);
            continue;
        }

        fs::create_dir_all(&refs_dir).map_err(|e| format!("failed to create refs dir: {}", e))?;

        // Find all ELF files
        let entries = match fs::read_dir(&test_dir) {
            Ok(e) => e,
            Err(_) => continue,
        };

        for entry in entries.flatten() {
            let path = entry.path();
            if !path.is_file() || path.extension().is_some() {
                continue;
            }

            let name = match path.file_name().and_then(|n| n.to_str()) {
                Some(n) => n,
                None => continue,
            };

            if !name.ends_with("-01") {
                continue;
            }

            let ref_path = refs_dir.join(format!("{}.sig", name));

            if ref_path.exists() && !config.force {
                continue;
            }

            match generate_reference(&path, &ref_path, category) {
                Ok(()) => {
                    generated += 1;
                }
                Err(e) => {
                    eprintln!("  {}/{}: {}", category, name, e);
                }
            }
        }
    }

    Ok(generated)
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_category_parse() {
        assert_eq!(
            ArchTestCategory::parse("rv64i-I"),
            Some(ArchTestCategory::Rv64iI)
        );
        assert_eq!(
            ArchTestCategory::parse("rv64i_m/I"),
            Some(ArchTestCategory::Rv64iI)
        );
        assert_eq!(
            ArchTestCategory::parse("rv32i-Zicond"),
            Some(ArchTestCategory::Rv32iZicond)
        );
        assert_eq!(ArchTestCategory::parse("invalid"), None);
    }

    #[test]
    fn test_category_list_parse() {
        let cats = ArchTestCategory::parse_list("rv64i-I,rv64i-M").unwrap();
        assert_eq!(cats.len(), 2);
        assert_eq!(cats[0], ArchTestCategory::Rv64iI);
        assert_eq!(cats[1], ArchTestCategory::Rv64iM);
    }

    #[test]
    fn test_should_skip() {
        assert!(should_skip("fence_i-01"));
        assert!(should_skip("fence-01"));
        assert!(!should_skip("add-01"));
    }

    #[test]
    fn test_compare_signatures() {
        assert!(compare_signatures("deadbeef\n", "deadbeef"));
        assert!(compare_signatures("deadbeef\n  ", "  deadbeef\n"));
        assert!(!compare_signatures("deadbeef", "cafebabe"));
    }

    #[test]
    fn test_harness_dir_exists() {
        let dir = harness_dir();
        // The harness directory should exist (it's part of the crate)
        assert!(dir.join("model_test.h").exists() || !dir.exists());
    }
}
