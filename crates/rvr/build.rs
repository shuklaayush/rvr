use std::fs::{self, File};
use std::io::{self, Write};
use std::path::{Path, PathBuf};

fn main() {
    let manifest_dir = PathBuf::from(std::env::var("CARGO_MANIFEST_DIR").unwrap());
    let workspace_root = manifest_dir
        .parent()
        .and_then(|p| p.parent())
        .unwrap();
    let out_dir = PathBuf::from(std::env::var("OUT_DIR").unwrap());

    let riscv_tests_dir = workspace_root.join("bin/riscv-tests");
    let arch_tests_dir = workspace_root.join("bin/riscv-arch-test");

    emit_rerun_paths(&riscv_tests_dir);
    emit_rerun_paths(&arch_tests_dir);

    let _ = generate_riscv_tests_cases(&riscv_tests_dir, &workspace_root, &out_dir);
    let _ = generate_arch_tests_cases(&arch_tests_dir, &workspace_root, &out_dir);
}

fn generate_riscv_tests_cases(
    riscv_tests_dir: &Path,
    workspace_root: &Path,
    out_dir: &Path,
) -> io::Result<()> {
    let mut cases = Vec::new();
    if riscv_tests_dir.exists() {
        collect_files(riscv_tests_dir, &mut cases)?;
    }
    cases.sort();

    let out_path = out_dir.join("riscv_tests_cases.rs");
    let mut file = File::create(out_path)?;
    writeln!(file, "// Auto-generated by build.rs (do not edit by hand)")?;

    for path in cases {
        let rel = path.strip_prefix(workspace_root).unwrap_or(&path);
        let ident = ident_from_path(rel);
        writeln!(file, "test_case!({}, \"{}\");", ident, rel.display())?;
    }
    Ok(())
}

fn generate_arch_tests_cases(
    arch_tests_dir: &Path,
    workspace_root: &Path,
    out_dir: &Path,
) -> io::Result<()> {
    let mut cases = Vec::new();
    if arch_tests_dir.exists() {
        collect_arch_tests(arch_tests_dir, arch_tests_dir, &mut cases)?;
    }
    cases.sort_by(|a, b| a.0.cmp(&b.0));

    let out_path = out_dir.join("arch_tests_cases.rs");
    let mut file = File::create(out_path)?;
    writeln!(file, "// Auto-generated by build.rs (do not edit by hand)")?;

    for (test_path, ref_path) in cases {
        let rel = test_path.strip_prefix(workspace_root).unwrap_or(&test_path);
        let rel_ref = ref_path.strip_prefix(workspace_root).unwrap_or(&ref_path);
        let ident = ident_from_path(rel);
        writeln!(
            file,
            "arch_case!({}, \"{}\", \"{}\");",
            ident,
            rel.display(),
            rel_ref.display()
        )?;
    }
    Ok(())
}

fn collect_files(dir: &Path, out: &mut Vec<PathBuf>) -> io::Result<()> {
    for entry in fs::read_dir(dir)? {
        let entry = entry?;
        let path = entry.path();
        if path.is_dir() {
            collect_files(&path, out)?;
        } else if path.is_file() {
            out.push(path);
        }
    }
    Ok(())
}

fn emit_rerun_paths(root: &Path) {
    if !root.exists() {
        return;
    }
    let mut files = Vec::new();
    if collect_files(root, &mut files).is_ok() {
        for path in files {
            println!("cargo:rerun-if-changed={}", path.display());
        }
    }
}

fn collect_arch_tests(
    root: &Path,
    dir: &Path,
    out: &mut Vec<(PathBuf, PathBuf)>,
) -> io::Result<()> {
    for entry in fs::read_dir(dir)? {
        let entry = entry?;
        let path = entry.path();
        if path.is_dir() {
            if path.file_name().and_then(|n| n.to_str()) == Some("references") {
                continue;
            }
            collect_arch_tests(root, &path, out)?;
        } else if path.is_file() {
            if path.extension().and_then(|e| e.to_str()) == Some("sig") {
                continue;
            }
            let category = path.parent().and_then(|p| p.file_name()).unwrap_or_default();
            let ref_path = root.join("references").join(category).join(format!(
                "{}.sig",
                path.file_name().and_then(|n| n.to_str()).unwrap_or("")
            ));
            out.push((path, ref_path));
        }
    }
    Ok(())
}

fn ident_from_path(path: &Path) -> String {
    let mut s = String::new();
    for ch in path.to_string_lossy().chars() {
        if ch.is_ascii_alphanumeric() {
            s.push(ch);
        } else {
            s.push('_');
        }
    }
    if s.chars().next().map(|c| c.is_ascii_digit()).unwrap_or(false) {
        s.insert(0, '_');
    }
    s
}
